[
    {
        "name": "Singleton",
        "category": "Creational",
        "description": "El patrón Singleton se utiliza para garantizar que una clase tenga una única instancia durante la ejecución de un programa. Esto es útil cuando se desea controlar el acceso global a un recurso compartido o cuando se quiere evitar la creación de múltiples objetos que consuman recursos innecesariamente. El patrón Singleton proporciona un punto de acceso global a la instancia única de la clase y asegura que no se creen más instancias de la misma.",
        "implementation": "class Singleton:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super(Singleton, cls).__new__(cls)\n        return cls._instance\n\n    def __init__(self):\n        if not hasattr(self, 'initialized'):\n            self.initialized = True\n            self.value = 0\n\n    def set_value(self, value):\n        self.value = value\n\n    def get_value(self):\n        return self.value\n\nif __name__ == \"__main__\":\n    singleton1 = Singleton()\n    singleton2 = Singleton()\n\n    singleton1.set_value(100)\n    print(singleton2.get_value())  # Debería imprimir 100, ya que singleton1 y singleton2 son la misma instancia\n\n    singleton2.set_value(200)\n    print(singleton1.get_value())  # Debería imprimir 200, ya que singleton1 y singleton2 son la misma instancia\n",
        "uml": "images/singleton.png"
    },
    {
        "name": "Factory Method",
        "category": "Creational",
        "description": "El patrón Factory Method define una interfaz para crear objetos, pero delega la elección de la clase concreta a subclases. Este patrón permite a una clase delegar la responsabilidad de la creación de objetos a sus subclases, lo que facilita la extensibilidad del código y la creación de objetos de manera más flexible. El patrón Factory Method es especialmente útil cuando se desea crear objetos de diferentes tipos o cuando la lógica de creación de objetos es compleja.",
        "implementation": "from abc import ABC, abstractmethod\n\nclass Vehicle(ABC):\n    @abstractmethod\n    def start_engine(self):\n        pass\n\n    @abstractmethod\n    def stop_engine(self):\n        pass\n\n    @abstractmethod\n    def drive(self):\n        pass\n\nclass Car(Vehicle):\n    def start_engine(self):\n        print(\"Starting car engine\")\n\n    def stop_engine(self):\n        print(\"Stopping car engine\")\n\n    def drive(self):\n        print(\"Driving car\")\n\nclass Motorcycle(Vehicle):\n    def start_engine(self):\n        print(\"Starting motorcycle engine\")\n\n    def stop_engine(self):\n        print(\"Stopping motorcycle engine\")\n\n    def drive(self):\n        print(\"Driving motorcycle\")\n\nclass VehicleFactory:\n    @staticmethod\n    def create_vehicle(vehicle_type):\n        if vehicle_type == \"car\":\n            return Car()\n        elif vehicle_type == \"motorcycle\":\n            return Motorcycle()\n        else:\n            return None\n\nfactory = VehicleFactory()\n\nwhile True:\n    vehicle_type = input(\"Enter vehicle type (car or motorcycle): \").lower()\n\n    vehicle = factory.create_vehicle(vehicle_type)\n    if vehicle:\n        vehicle.start_engine()\n        vehicle.drive()\n        vehicle.stop_engine()\n        break\n    else:\n        print(\"Invalid vehicle type entered. Please enter 'car' or 'motorcycle'.\")\n",
        "uml": "images/factorymethod.png"
    },
    {
        "name": "Adapter",
        "category": "Structural",
        "description": "El patrón Adapter se utiliza para permitir que objetos con interfaces incompatibles trabajen juntos. Este patrón proporciona una capa de abstracción que convierte la interfaz de una clase en otra interfaz que el cliente espera. El patrón Adapter es útil cuando se desea reutilizar código existente que no cumple con una interfaz requerida por el cliente. El patrón Adapter permite la integración de componentes de software existentes y la creación de interfaces uniformes para diferentes sistemas.",
        "implementation": "class Target:\n    def request(self):\n        return \"Target: The default target's behavior.\"\n\nclass Adaptee:\n    def specific_request(self):\n        return \".eetpadA eht fo roivaheb laicepS\"\n\nclass Adapter(Target):\n    def __init__(self, adaptee):\n        self._adaptee = adaptee\n\n    def request(self):\n        return f\"Adapter: (TRANSLATED) {self._adaptee.specific_request()[::-1]}\"\n\ndef client_code(target):\n    print(target.request())\n\nif __name__ == \"__main__\":\n    adaptee = Adaptee()\n    print(\"Adaptee:\")\n    print(f\"Adaptee: {adaptee.specific_request()}\")\n\n    adapter = Adapter(adaptee)\n    print(\"Adapter:\")\n    client_code(adapter)\n",
        "uml": "images/adapter.png"
    },
    {
        "name": "Abstract Factory",
        "category": "Creational",
        "description": "El patrón Abstract Factory proporciona una interfaz para crear familias de objetos relacionados o dependientes sin especificar sus clases concretas. Este patrón se utiliza cuando se desea crear objetos de diferentes tipos que pertenecen a una familia de productos relacionados, pero se desea delegar la elección de la clase concreta a subclases. El patrón Abstract Factory es útil cuando se desea crear objetos de diferentes tipos que pertenecen a una familia de productos relacionados, pero se desea delegar la elección de la clase concreta a subclases.",
        "implementation": "from abc import ABC, abstractmethod\n\nclass Car(ABC):\n    @abstractmethod\n    def sellCar(self):\n        pass\n\nclass CarFactory(ABC):\n    @abstractmethod\n    def create_suv(self):\n        pass\n\n    @abstractmethod\n    def create_sedan(self):\n        pass\n\n    @abstractmethod\n    def create_hatchback(self):\n        pass\n\nclass ChevroletFactory(CarFactory):\n    def create_hatchback(self):\n        return ChevroletHatchback()\n\n    def create_sedan(self):\n        return ChevroletSedan()\n\n    def create_suv(self):\n        return ChevroletSuv()\n\nclass ChevroletHatchback(Hatchback):\n    def sellCar(self):\n        print(\"Selling Chevrolet Hatchback...\")\n\nclass ChevroletSedan(Sedan):\n    def sellCar(self):\n        print(\"Selling Chevrolet Sedan...\")\n\nclass ChevroletSuv(Suv):\n    def sellCar(self):\n        print(\"Selling Chevrolet SUV...\")\n\nclass MazdaFactory(CarFactory):\n    def create_hatchback(self):\n        return MazdaHatchback()\n\n    def create_sedan(self):\n        return MazdaSedan()\n\n    def create_suv(self):\n        return MazdaSuv()\n\nclass MazdaHatchback(Hatchback):\n    def sellCar(self):\n        print(\"Selling Mazda Hatchback...\")\n\nclass MazdaSedan(Sedan):\n    def sellCar(self):\n        print(\"Selling Mazda Sedan...\")\n\nclass MazdaSuv(Suv):\n    def sellCar(self):\n        print(\"Selling Mazda SUV...\")\n\nclass RenaultFactory(CarFactory):\n    def create_hatchback(self):\n        return RenaultHatchback()\n\n    def create_sedan(self):\n        return RenaultSedan()\n\n    def create_suv(self):\n        return RenaultSuv()\n\nclass RenaultHatchback(Hatchback):\n    def sellCar(self):\n        print(\"Selling Renault Hatchback...\")\n\nclass RenaultSedan(Sedan):\n    def sellCar(self):\n        print(\"Selling Renault Sedan...\")\n\nclass RenaultSuv(Suv):\n    def sellCar(self):\n        print(\"Selling Renault SUV...\")\n\nclass Hatchback(Car):\n    pass\n\nclass Sedan(Car):\n    pass\n\nclass Suv(Car):\n    pass\n\nif __name__ == \"__main__\":\n    mazdaFactory = MazdaFactory()\n    chevroletFactory = ChevroletFactory()\n    renaultFactory = RenaultFactory()\n\n    cars = [\n        mazdaFactory.create_hatchback(),\n        mazdaFactory.create_sedan(),\n        mazdaFactory.create_suv(),\n        chevroletFactory.create_hatchback(),\n        chevroletFactory.create_sedan(),\n        chevroletFactory.create_suv(),\n        renaultFactory.create_hatchback(),\n        renaultFactory.create_sedan(),\n        renaultFactory.create_suv()\n    ]\n\n    for car in cars:\n        car.sellCar()\n",
        "uml": "images/abstractfactory.png"
    },
    {
        "name": "Prototype",
        "category": "Creational",
        "description": "El patrón Prototype se utiliza para crear nuevos objetos copiando un objeto existente, conocido como prototipo. Este patrón es útil cuando la creación de un nuevo objeto es costosa en términos de recursos o tiempo, y se desea evitar la duplicación de código. El patrón Prototype permite la creación de nuevos objetos a partir de objetos existentes, lo que facilita la creación de objetos complejos y la reducción de la duplicación de código.",
        "implementation": "import copy\nfrom abc import ABC, abstractmethod\n\n# Prototype interface\nclass Prototype(ABC):\n    @abstractmethod\n    def clone(self) -> 'Prototype':\n        pass\n\n# Concrete prototype\nclass ConcretePrototype1(Prototype):\n    def __init__(self, field1: int, field2: str):\n        self.field1 = field1\n        self.field2 = field2\n\n    def clone(self) -> 'ConcretePrototype1':\n        return copy.deepcopy(self)\n\n# Another concrete prototype\nclass ConcretePrototype2(Prototype):\n    def __init__(self, field3: float, field4: list):\n        self.field3 = field3\n        self.field4 = field4\n\n    def clone(self) -> 'ConcretePrototype2':\n        return copy.deepcopy(self)\n\n# Client code\nif __name__ == \"__main__\":\n    prototype1 = ConcretePrototype1(1, \"Prototype1\")\n    prototype2 = ConcretePrototype2(3.14, [1, 2, 3])\n\n    clone1 = prototype1.clone()\n    clone2 = prototype2.clone()\n\n    print(\"Original and cloned objects for ConcretePrototype1:\")\n    print(f\"Original: ({prototype1.field1}, {prototype1.field2})\")\n    print(f\"Clone: ({clone1.field1}, {clone1.field2})\")\n\n    print(\"\\nOriginal and cloned objects for ConcretePrototype2:\")\n    print(f\"Original: ({prototype2.field3}, {prototype2.field4})\")\n    print(f\"Clone: ({clone2.field3}, {clone2.field4})\")\n",
        "uml": "images/prototype.png"
    },
    {
        "name": "Bridge",
        "category": "Structural",
        "description": "El patrón Bridge se utiliza para desacoplar una abstracción de su implementación, de modo que ambas puedan variar independientemente. Este patrón permite la separación de la interfaz de una abstracción de su implementación, lo que facilita la extensibilidad del código y la creación de sistemas más flexibles. El patrón Bridge es útil cuando se desea separar la interfaz de una abstracción de su implementación, lo que facilita la extensibilidad del código y la creación de sistemas más flexibles.",
        "implementation": "class Color:\n    def apply_color(self):\n        pass\n\nclass Red(Color):\n    def apply_color(self):\n        return \"Color: Red\"\n\nclass Blue(Color):\n    def apply_color(self):\n        return \"Color: Blue\"\n\nclass Shape:\n    def __init__(self, color):\n        self._color = color\n\n    def draw(self):\n        pass\n\nclass Circle(Shape):\n    def draw(self):\n        return f\"Circle drawn with {self._color.apply_color()}\"\n\nclass Square(Shape):\n    def draw(self):\n        return f\"Square drawn with {self._color.apply_color()}\"\n\nif __name__ == \"__main__\":\n    red = Red()\n    blue = Blue()\n\n    circle = Circle(red)\n    square = Square(blue)\n\n    print(circle.draw())\n    print(square.draw())\n",
        "uml": "images/bridge.png"
    },
    {
        "name": "Composite",
        "category": "Structural",
        "description": "El patrón Composite se utiliza para permitir a los clientes tratar objetos individuales y composiciones de objetos de manera uniforme. Este patrón permite la creación de estructuras de objetos jerárquicas, en las que los objetos individuales y las composiciones de objetos se tratan de manera uniforme. El patrón Composite es útil cuando se desea crear estructuras de objetos jerárquicas, como en aplicaciones de interfaz de usuario o en sistemas de archivos.",
        "implementation": "class Component:\n    def operation(self):\n        pass\n\n    def add(self, component):\n        pass\n\n    def remove(self, component):\n        pass\n\n    def is_composite(self):\n        return False\n\nclass Leaf(Component):\n    def operation(self):\n        return \"Leaf\"\n\nclass Composite(Component):\n    def __init__(self):\n        self._children = []\n\n    def add(self, component):\n        self._children.append(component)\n\n    def remove(self, component):\n        self._children.remove(component)\n\n    def is_composite(self):\n        return True\n\n    def operation(self):\n        results = []\n        for child in self._children:\n            results.append(child.operation())\n        return f\"Branch({'+'.join(results)})\"\n\ndef client_code(component):\n    print(f\"RESULT: {component.operation()}\")\n\ndef client_code2(component1, component2):\n    if component1.is_composite():\n        component1.add(component2)\n    print(f\"RESULT: {component1.operation()}\")\n\nif __name__ == \"__main__\":\n    simple = Leaf()\n    print(\"Client: I've got a simple component:\")\n    client_code(simple)\n    print()\n\n    tree = Composite()\n    branch1 = Composite()\n    branch1.add(Leaf())\n    branch1.add(Leaf())\n\n    branch2 = Composite()\n    branch2.add(Leaf())\n\n    tree.add(branch1)\n    tree.add(branch2)\n\n    print(\"Client: Now I've got a composite tree:\")\n    client_code(tree)\n    print()\n\n    print(\"Client: I can add a simple component to a composite tree:\")\n    client_code2(tree, simple)\n",
        "uml": "images/composite.png"
    },
    {
        "name": "Decorator",
        "category": "Structural",
        "description": "El patrón Decorator se utiliza para agregar funcionalidades a objetos de manera dinámica. Este patrón permite la adición de responsabilidades a objetos individuales en tiempo de ejecución, sin modificar su estructura. El patrón Decorator es útil cuando se desea agregar funcionalidades a objetos de manera flexible y extensible, sin afectar a otros objetos de la misma clase.",
        "implementation": "class Component:\n    def operation(self):\n        pass\n\nclass ConcreteComponent(Component):\n    def operation(self):\n        return \"ConcreteComponent\"\n\nclass Decorator(Component):\n    def __init__(self, component):\n        self._component = component\n\n    def operation(self):\n        return self._component.operation()\n\nclass ConcreteDecoratorA(Decorator):\n    def operation(self):\n        return f\"ConcreteDecoratorA({super().operation()})\"\n\nclass ConcreteDecoratorB(Decorator):\n    def operation(self):\n        return f\"ConcreteDecoratorB({super().operation()})\"\n\ndef client_code(component):\n    print(f\"RESULT: {component.operation()}\")\n\nif __name__ == \"__main__\":\n    simple = ConcreteComponent()\n    print(\"Client: I've got a simple component:\")\n    client_code(simple)\n    print()\n\n    decorator1 = ConcreteDecoratorA(simple)\n    decorator2 = ConcreteDecoratorB(decorator1)\n    print(\"Client: Now I've got a decorated component:\")\n    client_code(decorator2)\n",
        "uml": "images/decorator.png"
    },
    {
        "name": "Facade",
        "category": "Structural",
        "description": "El patrón Facade se utiliza para proporcionar una interfaz unificada para un conjunto de interfaces en un subsistema. Este patrón proporciona una interfaz simplificada y unificada para un conjunto de interfaces complejas en un subsistema, lo que facilita la integración de diferentes componentes de software. El patrón Facade es útil cuando se desea simplificar la interfaz de un subsistema complejo o cuando se desea ocultar la complejidad de un subsistema detrás de una interfaz simplificada.",
        "implementation": "class CPU:\n    def freeze(self):\n        print(\"CPU: Freezing processor.\")\n\n    def jump(self, position):\n        print(f\"CPU: Jumping to {position}.\")\n\n    def execute(self):\n        print(\"CPU: Executing instructions.\")\n\nclass Memory:\n    def load(self, position, data):\n        print(f\"Memory: Loading {data} into position {position}.\")\n\nclass HardDrive:\n    def read(self, lba, size):\n        print(f\"HardDrive: Reading {size} bytes from LBA {lba}.\")\n        return \"Some data\"\n\nclass ComputerFacade:\n    def __init__(self):\n        self._cpu = CPU()\n        self._memory = Memory()\n        self._hard_drive = HardDrive()\n\n    def start(self):\n        self._cpu.freeze()\n        self._memory.load(0x00, self._hard_drive.read(0x0, 1024))\n        self._cpu.jump(0x00)\n        self._cpu.execute()\n\nif __name__ == \"__main__\":\n    computer = ComputerFacade()\n    computer.start()\n",
        "uml": "images/facade.png"
    },
    {
        "name": "Flyweight",
        "category": "Structural",
        "description": "El patrón Flyweight se utiliza para compartir objetos de manera eficiente cuando se necesitan muchas instancias de objetos similares. Este patrón permite la creación de objetos ligeros que comparten datos comunes, lo que reduce el consumo de memoria y mejora el rendimiento. El patrón Flyweight es útil cuando se desea crear muchas instancias de objetos similares, como en aplicaciones de juegos o en sistemas de gráficos.",
        "implementation": "class Flyweight:\n    def __init__(self, shared_state):\n        self._shared_state = shared_state\n\n    def operation(self, unique_state):\n        shared = \", \".join(self._shared_state)\n        unique = \", \".join(unique_state)\n        print(f\"Flyweight: Shared ({shared}) and unique ({unique}) state.\")\n\nclass FlyweightFactory:\n    def __init__(self, initial_flyweights):\n        self._flyweights = {}\n        for state in initial_flyweights:\n            self._flyweights[self.get_key(state)] = Flyweight(state)\n\n    def get_key(self, state):\n        return \"_\".join(sorted(state))\n\n    def get_flyweight(self, shared_state):\n        key = self.get_key(shared_state)\n        if not self._flyweights.get(key):\n            print(\"FlyweightFactory: Can't find a flyweight, creating new one.\")\n            self._flyweights[key] = Flyweight(shared_state)\n        else:\n            print(\"FlyweightFactory: Reusing existing flyweight.\")\n        return self._flyweights[key]\n\n    def list_flyweights(self):\n        count = len(self._flyweights)\n        print(f\"FlyweightFactory: I have {count} flyweights:\")\n        for key in self._flyweights.keys():\n            print(key)\n\ndef add_car_to_database(ff, plates, owner, brand, model, color):\n    print(\"\\nClient: Adding a car to database.\")\n    flyweight = ff.get_flyweight([brand, model, color])\n    flyweight.operation([plates, owner])\n\nif __name__ == \"__main__\":\n    factory = FlyweightFactory([\n        [\"Chevrolet\", \"Camaro2018\", \"pink\"],\n        [\"Mercedes Benz\", \"C300\", \"black\"],\n        [\"Mercedes Benz\", \"C500\", \"red\"],\n        [\"BMW\", \"M5\", \"red\"],\n        [\"BMW\", \"X6\", \"white\"],\n    ])\n\n    factory.list_flyweights()\n\n    add_car_to_database(factory, \"CL234IR\", \"James Doe\", \"BMW\", \"M5\", \"red\")\n    add_car_to_database(factory, \"CL234IR\", \"James Doe\", \"BMW\", \"X1\", \"red\")\n\n    factory.list_flyweights()\n",
        "uml": "images/flyweight.png"
    },
    {
        "name": "Proxy",
        "category": "Structural",
        "description": "El patrón Proxy se utiliza para proporcionar un sustituto o marcador de posición para controlar el acceso a un objeto. Este patrón permite la creación de un objeto intermediario que actúa como un sustituto o un marcador de posición para otro objeto, lo que permite la implementación de mecanismos de control de acceso, de caché o de registro. El patrón Proxy es útil cuando se desea controlar el acceso a un objeto, cuando se desea implementar mecanismos de caché o cuando se desea implementar mecanismos de registro.",
        "implementation": "class RealSubject:\n    def request(self):\n        return \"RealSubject: Handling request.\"\n\nclass Proxy:\n    def __init__(self, real_subject):\n        self._real_subject = real_subject\n\n    def request(self):\n        if self.check_access():\n            result = self._real_subject.request()\n            self.log_access()\n            return result\n\n    def check_access(self):\n        print(\"Proxy: Checking access prior to firing a real request.\")\n        return True\n\n    def log_access(self):\n        print(\"Proxy: Logging the time of request.\")\n\ndef client_code(subject):\n    print(subject.request())\n\nif __name__ == \"__main__\":\n    real_subject = RealSubject()\n    proxy = Proxy(real_subject)\n    client_code(proxy)\n",
        "uml": "images/proxy.png"
    },
    {
        "name": "Chain of Responsibility",
        "category": "Behavioral",
        "description": "El patrón Chain of Responsibility se utiliza para pasar una solicitud a lo largo de una cadena de manejadores hasta que uno de ellos la procese. Este patrón permite la creación de una cadena de manejadores que pueden procesar una solicitud de manera secuencial, delegando la solicitud al siguiente manejador si no puede ser procesada. El patrón Chain of Responsibility es útil cuando se desea implementar mecanismos de procesamiento de solicitudes flexibles y escalables, como en aplicaciones de procesamiento de pedidos o en sistemas de registro de eventos. ",
        "implementation": "from abc import ABC, abstractmethod\n\n# Handler interface\nclass Handler(ABC):\n    @abstractmethod\n    def set_next(self, handler: 'Handler') -> 'Handler':\n        pass\n\n    @abstractmethod\n    def handle(self, request: str) -> str:\n        pass\n\n# Base handler\nclass AbstractHandler(Handler):\n    _next_handler: Handler = None\n\n    def set_next(self, handler: Handler) -> Handler:\n        self._next_handler = handler\n        return handler\n\n    def handle(self, request: str) -> str:\n        if self._next_handler:\n            return self._next_handler.handle(request)\n        return None\n\n# Concrete handlers\nclass MonkeyHandler(AbstractHandler):\n    def handle(self, request: str) -> str:\n        if request == \"Banana\":\n            return f\"Monkey: I'll eat the {request}.\"\n        else:\n            return super().handle(request)\n\nclass SquirrelHandler(AbstractHandler):\n    def handle(self, request: str) -> str:\n        if request == \"Nut\":\n            return f\"Squirrel: I'll eat the {request}.\"\n        else:\n            return super().handle(request)\n\nclass DogHandler(AbstractHandler):\n    def handle(self, request: str) -> str:\n        if request == \"MeatBone\":\n            return f\"Dog: I'll eat the {request}.\"\n        else:\n            return super().handle(request)\n\n# Client code\nif __name__ == \"__main__\":\n    monkey = MonkeyHandler()\n    squirrel = SquirrelHandler()\n    dog = DogHandler()\n\n    monkey.set_next(squirrel).set_next(dog)\n\n    for item in [\"Nut\", \"Banana\", \"Cup of coffee\"]:\n        result = monkey.handle(item)\n        if result:\n            print(f\"  {result}\")\n        else:\n            print(f\"  {item} was left untouched.\")\n",
        "uml": "images/chainofresponsibility.png"
    },
    {
        "name": "Command",
        "category": "Behavioral",
        "description": "El patrón Command se utiliza para encapsular una solicitud como un objeto, lo que permite parametrizar los clientes con diferentes solicitudes, colas o registros de solicitudes y soportar operaciones que se pueden deshacer. Este patrón permite la creación de objetos de solicitud que encapsulan una operación y sus parámetros, lo que facilita la implementación de mecanismos de deshacer/rehacer, de colas de solicitudes y de registros de solicitudes. El patrón Command es útil cuando se desea implementar mecanismos de deshacer/rehacer, de colas de solicitudes o de registros de solicitudes, como en aplicaciones de edición de texto o en sistemas de procesamiento de transacciones.",
        "implementation": "from abc import ABC, abstractmethod\n\n# Command interface\nclass Command(ABC):\n    @abstractmethod\n    def execute(self) -> None:\n        pass\n\n# Concrete commands\nclass LightOnCommand(Command):\n    def __init__(self, light: 'Light'):\n        self._light = light\n\n    def execute(self) -> None:\n        self._light.turn_on()\n\nclass LightOffCommand(Command):\n    def __init__(self, light: 'Light'):\n        self._light = light\n\n    def execute(self) -> None:\n        self._light.turn_off()\n\nclass StereoOnWithCDCommand(Command):\n    def __init__(self, stereo: 'Stereo'):\n        self._stereo = stereo\n\n    def execute(self) -> None:\n        self._stereo.on()\n        self._stereo.set_cd()\n        self._stereo.set_volume(11)\n\nclass StereoOffCommand(Command):\n    def __init__(self, stereo: 'Stereo'):\n        self._stereo = stereo\n\n    def execute(self) -> None:\n        self._stereo.off()\n\n# Receiver classes\nclass Light:\n    def turn_on(self) -> None:\n        print(\"Light is on\")\n\n    def turn_off(self) -> None:\n        print(\"Light is off\")\n\nclass Stereo:\n    def on(self) -> None:\n        print(\"Stereo is on\")\n\n    def off(self) -> None:\n        print(\"Stereo is off\")\n\n    def set_cd(self) -> None:\n        print(\"Stereo is set for CD input\")\n\n    def set_volume(self, volume: int) -> None:\n        print(f\"Stereo volume set to {volume}\")\n\n# Invoker\nclass RemoteControl:\n    def __init__(self):\n        self._on_commands = {}\n        self._off_commands = {}\n\n    def set_command(self, slot: str, on_command: Command, off_command: Command) -> None:\n        self._on_commands[slot] = on_command\n        self._off_commands[slot] = off_command\n\n    def on_button_was_pushed(self, slot: str) -> None:\n        if slot in self._on_commands:\n            self._on_commands[slot].execute()\n\n    def off_button_was_pushed(self, slot: str) -> None:\n        if slot in self._off_commands:\n            self._off_commands[slot].execute()\n\n# Client code\nif __name__ == \"__main__\":\n    remote_control = RemoteControl()\n\n    living_room_light = Light()\n    stereo = Stereo()\n\n    living_room_light_on = LightOnCommand(living_room_light)\n    living_room_light_off = LightOffCommand(living_room_light)\n    stereo_on_with_cd = StereoOnWithCDCommand(stereo)\n    stereo_off = StereoOffCommand(stereo)\n\n    remote_control.set_command(\"Living Room Light\", living_room_light_on, living_room_light_off)\n    remote_control.set_command(\"Stereo\", stereo_on_with_cd, stereo_off)\n\n    print(\"-- Pushing buttons --\")\n    remote_control.on_button_was_pushed(\"Living Room Light\")\n    remote_control.off_button_was_pushed(\"Living Room Light\")\n    remote_control.on_button_was_pushed(\"Stereo\")\n    remote_control.off_button_was_pushed(\"Stereo\")\n",
        "uml": "images/command.png"
    },
    {
        "name": "Iterator",
        "category": "Behavioral",
        "description": "El patrón Iterator se utiliza para proporcionar un modo de acceder secuencialmente a los elementos de un objeto agregado sin exponer su representación subyacente. Este patrón permite la creación de objetos iteradores que pueden recorrer una estructura de datos agregada de manera secuencial, sin exponer los detalles de la implementación de la estructura de datos. El patrón Iterator es útil cuando se desea recorrer una estructura de datos agregada de manera secuencial, como en aplicaciones de procesamiento de datos o en sistemas de gestión de bases de datos.",
        "implementation": "class Employee:\n    def __init__(self, name: str, position: str):\n        self.name = name\n        self.position = position\n        self.subordinates = []\n\n    def add_subordinate(self, subordinate: 'Employee'):\n        self.subordinates.append(subordinate)\n\n    def __str__(self):\n        return f'{self.position}: {self.name}'\n\nclass OrgIterator:\n    def __init__(self, root: Employee):\n        self.stack = [root]\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if not self.stack:\n            raise StopIteration\n        \n        current = self.stack.pop()\n        self.stack.extend(reversed(current.subordinates))\n        return current\n\nclass Organization:\n    def __init__(self, root: Employee):\n        self.root = root\n\n    def __iter__(self):\n        return OrgIterator(self.root)\n\nceo = Employee('Santiago', 'CEO')\ncto = Employee('Camilo', 'QA')\ndev1 = Employee('Felipe', 'DESARROLLADOR')\ndev2 = Employee('Martin', 'DESARROLLADOR')\ncfo = Employee('Andres', 'ARQUITECTO')\naccountant = Employee('Maria', 'PROJECT MANAGER')\n\nceo.add_subordinate(cto)\nceo.add_subordinate(cfo)\ncto.add_subordinate(dev1)\ncto.add_subordinate(dev2)\ncfo.add_subordinate(accountant)\n\norganization = Organization(ceo)\n\nfor employee in organization:\n    print(employee)\n",
        "uml": "images/iterator.png"
    },
    {
        "name": "Mediator",
        "category": "Behavioral",
        "description": "El patrón Mediator se utiliza para definir un objeto que encapsula cómo interactúan un conjunto de objetos. Este patrón permite la creación de un objeto intermediario que actúa como un mediador entre un conjunto de objetos, lo que facilita la comunicación entre ellos y promueve el acoplamiento suelto. El patrón Mediator es útil cuando se desea implementar mecanismos de comunicación entre objetos flexibles y escalables, como en aplicaciones de interfaz de usuario o en sistemas de eventos.",
        "implementation": "from abc import ABC, abstractmethod\n\n# Mediator interface\nclass Mediator(ABC):\n    @abstractmethod\n    def notify(self, sender: object, event: str) -> None:\n        pass\n\n# Concrete Mediator\nclass ConcreteMediator(Mediator):\n    def __init__(self, component1: 'Component1', component2: 'Component2'):\n        self._component1 = component1\n        self._component1.set_mediator(self)\n        self._component2 = component2\n        self._component2.set_mediator(self)\n\n    def notify(self, sender: object, event: str) -> None:\n        if event == \"A\":\n            print(\"Mediator reacts on A and triggers following operations:\")\n            self._component2.do_c()\n        elif event == \"D\":\n            print(\"Mediator reacts on D and triggers following operations:\")\n            self._component1.do_b()\n            self._component2.do_c()\n\n# Base Component\nclass BaseComponent:\n    def __init__(self, mediator: Mediator = None):\n        self._mediator = mediator\n\n    def set_mediator(self, mediator: Mediator) -> None:\n        self._mediator = mediator\n\n# Concrete Components\nclass Component1(BaseComponent):\n    def do_a(self) -> None:\n        print(\"Component 1 does A.\")\n        self._mediator.notify(self, \"A\")\n\n    def do_b(self) -> None:\n        print(\"Component 1 does B.\")\n\nclass Component2(BaseComponent):\n    def do_c(self) -> None:\n        print(\"Component 2 does C.\")\n\n    def do_d(self) -> None:\n        print(\"Component 2 does D.\")\n        self._mediator.notify(self, \"D\")\n\n# Client code\nif __name__ == \"__main__\":\n    c1 = Component1()\n    c2 = Component2()\n    mediator = ConcreteMediator(c1, c2)\n\n    print(\"Client triggers operation A.\")\n    c1.do_a()\n\n    print(\"\\nClient triggers operation D.\")\n    c2.do_d()\n",
        "uml": "images/mediator.png"
    },
    {
        "name": "Memento",
        "category": "Behavioral",
        "description": "El patrón Memento se utiliza para capturar y externalizar el estado interno de un objeto sin violar la encapsulación, de modo que el objeto pueda volver a ese estado más tarde. Este patrón permite la creación de objetos memento que capturan el estado interno de otro objeto, lo que facilita la implementación de mecanismos de deshacer/rehacer y de registro de estados. El patrón Memento es útil cuando se desea implementar mecanismos de deshacer/rehacer o de registro de estados, como en aplicaciones de edición de texto o en sistemas de gestión de transacciones.",
        "implementation": "class Memento:\n    def __init__(self, state: str):\n        self._state = state\n\n    def get_state(self) -> str:\n        return self._state\n\nclass Originator:\n    def __init__(self, state: str):\n        self._state = state\n\n    def set_state(self, state: str) -> None:\n        print(f\"Originator: Setting state to {state}\")\n        self._state = state\n\n    def save_to_memento(self) -> Memento:\n        print(f\"Originator: Saving to Memento.\")\n        return Memento(self._state)\n\n    def restore_from_memento(self, memento: Memento) -> None:\n        self._state = memento.get_state()\n        print(f\"Originator: State after restoring from Memento: {self._state}\")\n\nclass Caretaker:\n    def __init__(self):\n        self._mementos = []\n\n    def add_memento(self, memento: Memento) -> None:\n        self._mementos.append(memento)\n\n    def get_memento(self, index: int) -> Memento:\n        return self._mementos[index]\n\n# Client code\nif __name__ == \"__main__\":\n    originator = Originator(\"State1\")\n    caretaker = Caretaker()\n\n    caretaker.add_memento(originator.save_to_memento())\n    originator.set_state(\"State2\")\n    caretaker.add_memento(originator.save_to_memento())\n    originator.set_state(\"State3\")\n    caretaker.add_memento(originator.save_to_memento())\n\n    originator.restore_from_memento(caretaker.get_memento(0))\n    originator.restore_from_memento(caretaker.get_memento(1))\n",
        "uml": "images/memento.png"
    },
    {
        "name": "Observer",
        "category": "Behavioral",
        "description": "El patrón Observer se utiliza para establecer una relación de uno a muchos entre objetos, de modo que cuando un objeto cambia su estado, todos los objetos dependientes sean notificados y actualizados automáticamente. Este patrón es útil cuando se desea implementar un mecanismo de notificación y actualización entre objetos, como en aplicaciones de interfaz de usuario o en sistemas de eventos. El patrón Observer permite la desacoplamiento entre objetos y facilita la implementación de mecanismos de notificación y actualización flexibles y escalables.",
        "implementation": "from abc import ABC, abstractmethod\n\n# Subscriber interface\nclass Subscriber(ABC):\n    @abstractmethod\n    def update(self, magazine_name: str, issue: str) -> None:\n        pass\n\n# EventManager class\nclass EventManager:\n    def __init__(self):\n        self._listeners = {}\n\n    def subscribe(self, event_type: str, listener: Subscriber) -> None:\n        if event_type not in self._listeners:\n            self._listeners[event_type] = []\n        self._listeners[event_type].append(listener)\n\n    def unsubscribe(self, event_type: str, listener: Subscriber) -> None:\n        if event_type in self._listeners:\n            self._listeners[event_type].remove(listener)\n\n    def notify(self, event_type: str, *args) -> None:\n        if event_type in self._listeners:\n            for listener in self._listeners[event_type]:\n                listener.update(*args)\n\n# Magazine class\nclass Magazine:\n    def __init__(self, name: str):\n        self.name = name\n        self.events = EventManager()\n\n    def new_issue(self, issue: str) -> None:\n        print(f\"{self.name}: New issue released - {issue}\")\n        self.events.notify(\"new_issue\", self.name, issue)\n\n# Concrete Subscribers\nclass LoggingSubscriber(Subscriber):\n    def __init__(self, log_file: str):\n        self.log_file = log_file\n\n    def update(self, magazine_name: str, issue: str) -> None:\n        with open(self.log_file, 'a') as log:\n            log.write(f\"{magazine_name} released new issue: {issue}\\n\")\n        print(f\"Logged: {magazine_name} released new issue: {issue}\")\n\nclass EmailSubscriber(Subscriber):\n    def __init__(self, email: str):\n        self.email = email\n\n    def update(self, magazine_name: str, issue: str) -> None:\n        # Simulating sending an email\n        print(f\"Email to {self.email}: {magazine_name} released new issue: {issue}\")\n\n# Application Configuration\nif __name__ == \"__main__\":\n    tech_magazine = Magazine(\"Tech Monthly\")\n\n    logger = LoggingSubscriber(\"log.txt\")\n    email_alert = EmailSubscriber(\"subscriber@example.com\")\n\n    tech_magazine.events.subscribe(\"new_issue\", logger)\n    tech_magazine.events.subscribe(\"new_issue\", email_alert)\n\n    tech_magazine.new_issue(\"May 2024 Edition\")\n    tech_magazine.new_issue(\"June 2024 Edition\")\n",
        "uml": "images/observer.png"
    },
    {
        "name": "State",
        "category": "Behavioral",
        "description": "El patrón State se utiliza para permitir que un objeto altere su comportamiento cuando su estado interno cambia. Este patrón permite la creación de objetos de estado que encapsulan el comportamiento de un objeto en un estado particular, lo que facilita la implementación de mecanismos de cambio de estado y de comportamiento dinámico. El patrón State es útil cuando se desea implementar mecanismos de cambio de estado o de comportamiento dinámico, como en aplicaciones de procesamiento de pedidos o en sistemas de gestión de trabajo.",
        "implementation": "from abc import ABC, abstractmethod\n\nclass State(ABC):\n    @abstractmethod\n    def press_power_button(self, device):\n        pass\n\n    @abstractmethod\n    def press_home_button(self, device):\n        pass\n\nclass OffState(State):\n    def press_power_button(self, device):\n        from LockedState import LockedState\n        print(\"Device is turning on and entering Locked State.\")\n        device.set_state(LockedState())\n    \n    def press_home_button(self, device):\n        print(\"Device is off. Home button does nothing.\")\n\nclass LockedState(State):\n    def press_power_button(self, device):\n        from OffState import OffState\n        print(\"Device is turning off.\")\n        device.set_state(OffState())\n    \n    def press_home_button(self, device):\n        from ReadyState import ReadyState\n        print(\"Device is unlocking and entering Ready State.\")\n        device.set_state(ReadyState())\n\nclass ReadyState(State):\n    def press_power_button(self, device):\n        from LockedState import LockedState\n        print(\"Device is locking.\")\n        device.set_state(LockedState())\n    \n    def press_home_button(self, device):\n        print(\"Device is already in Ready State.\")\n\nclass Device:\n    def __init__(self):\n        self.state = OffState()\n    \n    def set_state(self, state):\n        self.state = state\n    \n    def press_power_button(self):\n        self.state.press_power_button(self)\n    \n    def press_home_button(self):\n        self.state.press_home_button(self)\n\nif __name__ == \"__main__\":\n    device = Device()\n\n    print(\"Initial State: OffState\")\n    device.press_power_button()  \n    device.press_home_button()   \n    device.press_power_button() \n    device.press_power_button()\n",
        "uml": "images/state.png"
    },
    {
        "name": "Builder",
        "category": "Creational",
        "description": "El patrón Builder se utiliza para permitir la construcción de objetos complejos paso a paso. Este patrón permite la creación de objetos complejos de manera incremental, utilizando un objeto constructor que construye el objeto paso a paso. El patrón Builder es útil cuando se desea crear objetos complejos con muchos parámetros opcionales o cuando se desea implementar mecanismos de construcción de objetos flexibles y extensibles.",
        "implementation": "```java\npublic class Product {\n    private final String part1;\n    private final String part2;\n    private final String part3;\n\n    private Product(Builder builder) {\n        this.part1 = builder.part1;\n        this.part2 = builder.part2;\n        this.part3 = builder.part3;\n    }\n\n    public static class Builder {\n        private String part1;\n        private String part2;\n        private String part3;\n\n        public Builder setPart1(String part1) {\n            this.part1 = part1;\n            return this;\n        }\n\n        public Builder setPart2(String part2) {\n            this.part2 = part2;\n            return this;\n        }\n\n        public Builder setPart3(String part3) {\n            this.part3 = part3;\n            return this;\n        }\n\n        public Product build() {\n            return new Product(this);\n        }\n    }\n}\n```",
        "uml": "images/builder.png"
    },
    {
        "name": "Strategy",
        "category": "Behavioral",
        "description": "El patrón Strategy se utiliza para definir una familia de algoritmos, encapsular cada uno de ellos y hacerlos intercambiables. Este patrón permite la creación de objetos de estrategia que encapsulan un algoritmo particular, lo que facilita la implementación de mecanismos de selección de algoritmos en tiempo de ejecución. El patrón Strategy es útil cuando se desea implementar mecanismos de selección de algoritmos flexibles y extensibles, como en aplicaciones de procesamiento de datos o en sistemas de gestión de reglas de negocio.",
        "implementation": "from abc import ABC, abstractmethod\n\n# Strategy interface\nclass PriceStrategy(ABC):\n    @abstractmethod\n    def calculate_price(self, base_price: int) -> float:\n        pass\n\n# Concrete strategies\nclass AdultStrategy(PriceStrategy):\n    def calculate_price(self, base_price: int) -> float:\n        return base_price\n\nclass ChildStrategy(PriceStrategy):\n    def calculate_price(self, base_price: int) -> float:\n        return base_price * 0.5\n\nclass StudentStrategy(PriceStrategy):\n    def calculate_price(self, base_price: int) -> float:\n        return base_price * 0.8\n\n# Context\nclass TicketPriceCalculator:\n    def __init__(self, strategy: PriceStrategy):\n        self._strategy = strategy\n\n    def set_strategy(self, strategy: PriceStrategy):\n        self._strategy = strategy\n\n    def calculate(self, base_price: int) -> float:\n        return self._strategy.calculate_price(base_price)\n\n# Client\nif __name__ == \"__main__\":\n    calculator = TicketPriceCalculator(AdultStrategy())\n    print(\"Adult price:\", calculator.calculate(100))\n    calculator.set_strategy(ChildStrategy())\n    print(\"Child price:\", calculator.calculate(100))\n    calculator.set_strategy(StudentStrategy())\n    print(\"Student price:\", calculator.calculate(100))\n",
        "uml": "images/strategy.png"
    },
    {
        "name": "Template Method",
        "category": "Behavioral",
        "description": "El patrón Template Method se utiliza para definir el esqueleto de un algoritmo en una operación, diferir algunos pasos a las subclases. Este patrón permite la creación de una clase abstracta que define un algoritmo en términos de una secuencia de pasos, dejando algunos pasos a las subclases para implementar. El patrón Template Method es útil cuando se desea implementar algoritmos flexibles y extensibles, permitiendo que las subclases proporcionen implementaciones específicas de algunos pasos del algoritmo.",
        "implementation": "from abc import ABC, abstractmethod\n\n# Abstract class with the template method\nclass DataProcessor(ABC):\n    def process(self) -> None:\n        self.read_data()\n        self.process_data()\n        self.save_data()\n\n    @abstractmethod\n    def read_data(self) -> None:\n        pass\n\n    @abstractmethod\n    def process_data(self) -> None:\n        pass\n\n    @abstractmethod\n    def save_data(self) -> None:\n        pass\n\n# Concrete classes\nclass CSVDataProcessor(DataProcessor):\n    def read_data(self) -> None:\n        print(\"Reading data from CSV file\")\n\n    def process_data(self) -> None:\n        print(\"Processing CSV data\")\n\n    def save_data(self) -> None:\n        print(\"Saving processed data to CSV file\")\n\nclass JSONDataProcessor(DataProcessor):\n    def read_data(self) -> None:\n        print(\"Reading data from JSON file\")\n\n    def process_data(self) -> None:\n        print(\"Processing JSON data\")\n\n    def save_data(self) -> None:\n        print(\"Saving processed data to JSON file\")\n\n# Client code\nif __name__ == \"__main__\":\n    csv_processor = CSVDataProcessor()\n    json_processor = JSONDataProcessor()\n\n    print(\"Processing CSV data:\")\n    csv_processor.process()\n\n    print(\"\\nProcessing JSON data:\")\n    json_processor.process()\n",
        "uml": "images/templatemethod.png"
    },
    {
        "name": "Visitor",
        "category": "Behavioral",
        "description": "El patrón Visitor se utiliza para representar una operación que se va a realizar sobre los elementos de una estructura de objetos. Este patrón permite la creación de objetos visitantes que pueden recorrer una estructura de objetos y realizar una operación específica sobre cada elemento. El patrón Visitor es útil cuando se desea realizar una operación sobre una estructura de objetos compleja, como en aplicaciones de procesamiento de datos o en sistemas de gestión de bases de datos.",
        "implementation": "from abc import ABC, abstractmethod\n\nclass Cliente(ABC):\n    def __init__(self, nombre, fecha_nacimiento, direccion):\n        self.nombre = nombre\n        self.fecha_nacimiento = fecha_nacimiento\n        self.direccion = direccion\n\n    @abstractmethod\n    def accept(self, visitor):\n        pass\n\nclass ClienteRegular(Cliente):\n    def accept(self, visitor):\n        visitor.visit_cliente_regular(self)\n\nclass ClienteVIP(Cliente):\n    def accept(self, visitor):\n        visitor.visit_cliente_vip(self)\n\nclass ClienteCorporativo(Cliente):\n    def accept(self, visitor):\n        visitor.visit_cliente_corporativo(self)\n\nclass MensajeVisitor(Visitor):\n    def visit_cliente_regular(self, cliente):\n        print(f\"Hola {cliente.nombre}, gracias por ser nuestro cliente regular. ¡Te esperamos pronto!\")\n\n    def visit_cliente_vip(self, cliente):\n        print(f\"Hola {cliente.nombre}, gracias por ser nuestro cliente VIP. ¡Disfruta de nuestros servicios exclusivos!\")\n\n    def visit_cliente_corporativo(self, cliente):\n        print(f\"Hola {cliente.nombre}, gracias por representar a {cliente.direccion}. ¡Nos enorgullece tenerlos como clientes corporativos!\")\n\nif __name__ == \"__main__\":\n    from Cliente import ClienteRegular\n    from Cliente import ClienteVIP\n    from Cliente import ClienteCorporativo\n    from datetime import date\n    clientes = [\n        ClienteRegular(\"Juan Camilo\", date(1985, 6, 15), \"Avenida Bolívar Calle 4N\"),\n        ClienteVIP(\"Maria Angélica\", date(1979, 12, 22), \"Edificio Nogal, Calle 6N\"),\n        ClienteCorporativo(\"Santiago\", date(1990, 3, 8), \"Empresa COLTECH, Calle 3N #456\")\n    ]\n\n    visitor = MensajeVisitor()\n\n    for cliente in clientes:\n        cliente.accept(visitor)\n\nclass Visitor(ABC):\n    @abstractmethod\n    def visit_cliente_regular(self, cliente):\n        pass\n\n    @abstractmethod\n    def visit_cliente_vip(self, cliente):\n        pass\n\n    @abstractmethod\n    def visit_cliente_corporativo(self, cliente):\n        pass\n",
        "uml": "images/visitor.png"
    }
]
