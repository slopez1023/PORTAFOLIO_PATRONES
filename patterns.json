[
    {
        "name": "Singleton",
        "category": "Creational",
        "description": "El patrón Singleton asegura que una clase solo tenga una instancia y proporciona un punto de acceso global a ella.",
        "implementation": "```java\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```",
        "uml": "images/singleton.png"
    },
    {
        "name": "Factory Method",
        "category": "Creational",
        "description": "El patrón Factory Method define una interfaz para crear un objeto, pero deja que las subclases decidan qué clase instanciar.",
        "implementation": "```java\npublic abstract class Product {\n    // Abstract product\n}\npublic class ConcreteProduct extends Product {\n    // Concrete product\n}\npublic abstract class Creator {\n    public abstract Product factoryMethod();\n}\npublic class ConcreteCreator extends Creator {\n    @Override\n    public Product factoryMethod() {\n        return new ConcreteProduct();\n    }\n}\n```",
        "uml": "images/factory_method.png"
    },
    {
        "name": "Observer",
        "category": "Behavioral",
        "description": "El patrón Observer define una dependencia de uno a muchos entre objetos, de manera que cuando un objeto cambia de estado, todos sus dependientes son notificados y actualizados automáticamente.",
        "implementation": "```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Subject {\n    private List<Observer> observers = new ArrayList<>();\n    private int state;\n\n    public int getState() {\n        return state;\n    }\n\n    public void setState(int state) {\n        this.state = state;\n        notifyAllObservers();\n    }\n\n    public void attach(Observer observer){\n        observers.add(observer);\n    }\n\n    public void notifyAllObservers(){\n        for (Observer observer : observers) {\n            observer.update();\n        }\n    }\n}\n\npublic abstract class Observer {\n    protected Subject subject;\n    public abstract void update();\n}\n\npublic class ConcreteObserver extends Observer {\n    public ConcreteObserver(Subject subject){\n        this.subject = subject;\n        this.subject.attach(this);\n    }\n\n    @Override\n    public void update() {\n        System.out.println(\"State changed: \" + subject.getState());\n    }\n}\n```",
        "uml": "images/observer.png"
    },
    {
        "name": "Adapter",
        "category": "Structural",
        "description": "El patrón Adapter permite que clases con interfaces incompatibles trabajen juntas.",
        "implementation": "```java\npublic interface Target {\n    void request();\n}\n\npublic class Adaptee {\n    public void specificRequest() {\n        System.out.println(\"Specific request\");\n    }\n}\n\npublic class Adapter implements Target {\n    private Adaptee adaptee;\n\n    public Adapter(Adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n\n    @Override\n    public void request() {\n        adaptee.specificRequest();\n    }\n}\n```",
        "uml": "images/adapter.png"
    },
    {
        "name": "Abstract Factory",
        "category": "Creational",
        "description": "El patrón Abstract Factory proporciona una interfaz para crear familias de objetos relacionados o dependientes sin especificar sus clases concretas.",
        "implementation": "```java\npublic interface AbstractFactory {\n    ProductA createProductA();\n    ProductB createProductB();\n}\n\npublic class ConcreteFactory1 implements AbstractFactory {\n    public ProductA createProductA() {\n        return new ProductA1();\n    }\n    public ProductB createProductB() {\n        return new ProductB1();\n    }\n}\n\npublic class ConcreteFactory2 implements AbstractFactory {\n    public ProductA createProductA() {\n        return new ProductA2();n}\n    public ProductB createProductB() {\n        return new ProductB2();\n    }\n}\n```",
        "uml": "images/abstract_factory.png"
    },
    {
        "name": "Prototype",
        "category": "Creational",
        "description": "El patrón Prototype se usa para crear nuevos objetos copiando un objeto existente, conocido como prototipo.",
        "implementation": "```java\npublic class Prototype implements Cloneable {\n    private String field;\n    public Prototype(String field) {\n        this.field = field;\n    }\n    public Prototype clone() {\n        try {\n            return (Prototype) super.clone();\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n```",
        "uml": "images/prototype.png"
    },
    {
        "name": "Bridge",
        "category": "Structural",
        "description": "El patrón Bridge desacopla una abstracción de su implementación para que ambas puedan variar independientemente.",
        "implementation": "```java\npublic interface Implementor {\n    void operationImpl();\n}\n\npublic class ConcreteImplementorA implements Implementor {\n    public void operationImpl() {\n        // Implementación específica\n    }\n}\n\npublic class ConcreteImplementorB implements Implementor {\n    public void operationImpl() {\n        // Implementación específica\n    }\n}\n\npublic abstract class Abstraction {\n    protected Implementor implementor;\n    public Abstraction(Implementor implementor) {\n        this.implementor = implementor;\n    }\n    public abstract void operation();\n}\n\npublic class RefinedAbstraction extends Abstraction {\n    public RefinedAbstraction(Implementor implementor) {\n        super(implementor);\n    }\n    public void operation() {\n        implementor.operationImpl();\n    }\n}\n```",
        "uml": "images/bridge.png"
    },
    {
        "name": "Composite",
        "category": "Structural",
        "description": "El patrón Composite permite a los clientes tratar objetos individuales y composiciones de objetos de manera uniforme.",
        "implementation": "```java\npublic interface Component {\n    void operation();\n}\n\npublic class Leaf implements Component {\n    public void operation() {\n        // Implementación específica\n    }\n}\n\npublic class Composite implements Component {\n    private List<Component> children = new ArrayList<>();\n    public void operation() {\n        for (Component child : children) {\n            child.operation();\n        }\n    }\n    public void add(Component component) {\n        children.add(component);\n    }\n    public void remove(Component component) {\n        children.remove(component);\n    }\n}\n```",
        "uml": "images/composite.png"
    },
    {
        "name": "Decorator",
        "category": "Structural",
        "description": "El patrón Decorator permite añadir funcionalidades a objetos de manera dinámica.",
        "implementation": "```java\npublic interface Component {\n    void operation();\n}\n\npublic class ConcreteComponent implements Component {\n    public void operation() {\n        // Implementación específica\n    }\n}\n\npublic abstract class Decorator implements Component {\n    protected Component component;\n    public Decorator(Component component) {\n        this.component = component;\n    }\n    public void operation() {\n        component.operation();\n    }\n}\n\npublic class ConcreteDecoratorA extends Decorator {\n    public ConcreteDecoratorA(Component component) {\n        super(component);\n    }\n    public void operation() {\n        super.operation();\n        // Comportamiento adicional\n    }\n}\n```",
        "uml": "images/decorator.png"
    },
    {
        "name": "Facade",
        "category": "Structural",
        "description": "El patrón Facade proporciona una interfaz unificada para un conjunto de interfaces en un subsistema.",
        "implementation": "```java\npublic class Facade {\n    private Subsystem1 subsystem1;\n    private Subsystem2 subsystem2;\n    public Facade() {\n        subsystem1 = new Subsystem1();\n        subsystem2 = new Subsystem2();\n    }\n    public void operation() {\n        subsystem1.operation1();\n        subsystem2.operation2();\n    }\n}\n```",
        "uml": "images/facade.png"
    },
    {
        "name": "Flyweight",
        "category": "Structural",
        "description": "El patrón Flyweight utiliza el uso compartido para admitir eficientemente grandes cantidades de objetos de grano fino.",
        "implementation": "```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class FlyweightFactory {\n    private Map<String, Flyweight> flyweights = new HashMap<>();\n    public Flyweight getFlyweight(String key) {\n        if (!flyweights.containsKey(key)) {\n            flyweights.put(key, new ConcreteFlyweight(key));\n        }\n        return flyweights.get(key);\n    }\n}\n\npublic interface Flyweight {\n    void operation(String extrinsicState);\n}\n\npublic class ConcreteFlyweight implements Flyweight {\n    private String intrinsicState;\n    public ConcreteFlyweight(String intrinsicState) {\n        this.intrinsicState = intrinsicState;\n    }\n    public void operation(String extrinsicState) {\n        // Implementación específica\n    }\n}\n```",
        "uml": "images/flyweight.png"
    },
    {
        "name": "Proxy",
        "category": "Structural",
        "description": "El patrón Proxy proporciona un sustituto o placeholder para controlar el acceso a un objeto.",
        "implementation": "```java\npublic interface Subject {\n    void request();\n}\n\npublic class RealSubject implements Subject {\n    public void request() {\n        // Implementación específica\n    }\n}\n\npublic class Proxy implements Subject {\n    private RealSubject realSubject;\n    public void request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        realSubject.request();\n    }\n}\n```",
        "uml": "images/proxy.png"
    },
    {
        "name": "Chain of Responsibility",
        "category": "Behavioral",
        "description": "El patrón Chain of Responsibility permite pasar la solicitud a lo largo de una cadena de manejadores hasta que uno de ellos la procese.",
        "implementation": "```java\npublic abstract class Handler {\n    protected Handler successor;\n    public void setSuccessor(Handler successor) {\n        this.successor = successor;\n    }\n    public abstract void handleRequest(Request request);\n}\n\npublic class ConcreteHandler1 extends Handler {\n    public void handleRequest(Request request) {\n        if (request.getType() == RequestType.TYPE1) {\n            // Manejo específico\n        } else if (successor != null) {\n            successor.handleRequest(request);\n        }\n    }\n}\n\npublic class ConcreteHandler2 extends Handler {\n    public void handleRequest(Request request) {\n        if (request.getType() == RequestType.TYPE2) {\n            // Manejo específico\n        } else if (successor != null) {\n            successor.handleRequest(request);\n        }\n    }\n}\n```",
        "uml": "images/chain_of_responsibility.png"
    },
    {
        "name": "Command",
        "category": "Behavioral",
        "description": "El patrón Command convierte una solicitud en un objeto, lo que permite parametrizar los clientes con diferentes solicitudes, colas o registros de solicitudes y soportar operaciones que se pueden deshacer.",
        "implementation": "```java\npublic interface Command {\n    void execute();\n}\n\npublic class ConcreteCommand implements Command {\n    private Receiver receiver;\n    public ConcreteCommand(Receiver receiver) {\n        this.receiver = receiver;\n    }\n    public void execute() {\n        receiver.action();\n    }\n}\n\npublic class Invoker {\n    private Command command;\n    public void setCommand(Command command) {\n        this.command = command;\n    }\n    public void executeCommand() {\n        command.execute();\n    }\n}\n```",
        "uml": "images/command.png"
    },
    {
        "name": "Iterator",
        "category": "Behavioral",
        "description": "El patrón Iterator proporciona un modo de acceder secuencialmente a los elementos de un objeto agregado sin exponer su representación subyacente.",
        "implementation": "```java\npublic interface Iterator {\n    boolean hasNext();\n    Object next();\n}\n\npublic interface Aggregate {\n    Iterator createIterator();\n}\n\npublic class ConcreteAggregate implements Aggregate {\n    private List<Object> items = new ArrayList<>();\n    public Iterator createIterator() {\n        return new ConcreteIterator(this);\n    }\n    public int getCount() {\n        return items.size();\n    }\n    public Object getItem(int index) {\n        return items.get(index);\n    }\n}\n\npublic class ConcreteIterator implements Iterator {\n    private ConcreteAggregate aggregate;\n    private int current = 0;\n    public ConcreteIterator(ConcreteAggregate aggregate) {\n        this.aggregate = aggregate;\n    }\n    public boolean hasNext() {\n        return current < aggregate.getCount();\n    }\n    public Object next() {\n        return aggregate.getItem(current++);\n    }\n}\n```",
        "uml": "images/iterator.png"
    },
    {
        "name": "Mediator",
        "category": "Behavioral",
        "description": "El patrón Mediator define un objeto que encapsula cómo interactúan un conjunto de objetos. El mediador promueve el acoplamiento suelto al prevenir que los objetos se refieran entre sí explícitamente, y permite variar sus interacciones de manera independiente.",
        "implementation": "```java\npublic interface Mediator {\n    void sendMessage(String message, Colleague colleague);\n}\n\npublic class ConcreteMediator implements Mediator {\n    private List<Colleague> colleagues;\n    public void addColleague(Colleague colleague) {\n        colleagues.add(colleague);\n    }\n    public void sendMessage(String message, Colleague colleague) {\n        for (Colleague c : colleagues) {\n            if (c != colleague) {\n                c.receive(message);\n            }\n        }\n    }\n}\n\npublic abstract class Colleague {\n    protected Mediator mediator;\n    public Colleague(Mediator mediator) {\n        this.mediator = mediator;\n    }\n    public abstract void send(String message);\n    public abstract void receive(String message);\n}\n\npublic class ConcreteColleague extends Colleague {\n    public ConcreteColleague(Mediator mediator) {\n        super(mediator);\n    }\n    public void send(String message) {\n        mediator.sendMessage(message, this);\n    }\n    public void receive(String message) {\n        System.out.println(\"Received: \" + message);\n    }\n}\n```",
        "uml": "images/mediator.png"
    },
    {
        "name": "Memento",
        "category": "Behavioral",
        "description": "El patrón Memento captura y externaliza el estado interno de un objeto sin violar la encapsulación, de manera que el objeto pueda volver a ese estado más tarde.",
        "implementation": "```java\npublic class Memento {\n    private String state;\n    public Memento(String state) {\n        this.state = state;\n    }\n    public String getState() {\n        return state;\n    }\n}\n\npublic class Originator {\n    private String state;\n    public void setState(String state) {\n        this.state = state;\n    }\n    public String getState() {\n        return state;\n    }\n    public Memento saveStateToMemento() {\n        return new Memento(state);\n    }\n    public void getStateFromMemento(Memento memento) {\n        state = memento.getState();\n    }\n}\n\npublic class Caretaker {\n    private List<Memento> mementoList = new ArrayList<>();\n    public void add(Memento state) {\n        mementoList.add(state);\n    }\n    public Memento get(int index) {\n        return mementoList.get(index);\n    }\n}\n```",
        "uml": "images/memento.png"
    },
    {
        "name": "Observer",
        "category": "Behavioral",
        "description": "El patrón Observer define una dependencia de uno a muchos entre objetos, de manera que cuando un objeto cambia de estado, todos sus dependientes son notificados y actualizados automáticamente.",
        "implementation": "```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Subject {\n    private List<Observer> observers = new ArrayList<>();\n    private int state;\n    public int getState() {\n        return state;\n    }\n    public void setState(int state) {\n        this.state = state;\n        notifyAllObservers();\n    }\n    public void attach(Observer observer){\n        observers.add(observer);\n    }\n    public void notifyAllObservers(){\n        for (Observer observer : observers) {\n            observer.update();\n        }\n    }\n}\n\npublic abstract class Observer {\n    protected Subject subject;\n    public abstract void update();\n}\n\npublic class ConcreteObserver extends Observer {\n    public ConcreteObserver(Subject subject){\n        this.subject = subject;\n        this.subject.attach(this);\n    }\n    @Override\n    public void update() {\n        System.out.println(\"State changed: \" + subject.getState());\n    }\n}\n```",
        "uml": "images/observer.png"
    },
    {
        "name": "State",
        "category": "Behavioral",
        "description": "El patrón State permite que un objeto altere su comportamiento cuando su estado interno cambia. El objeto parecerá cambiar su clase.",
        "implementation": "```java\npublic interface State {\n    void handle(Context context);\n}\n\npublic class ConcreteStateA implements State {\n    public void handle(Context context) {\n        context.setState(new ConcreteStateB());\n    }\n}\n\npublic class ConcreteStateB implements State {\n    public void handle(Context context) {\n        context.setState(new ConcreteStateA());\n    }\n}\n\npublic class Context {\n    private State state;\n    public Context() {\n        state = new ConcreteStateA();\n    }\n    public void setState(State state) {\n        this.state = state;\n    }\n    public void request() {\n        state.handle(this);\n    }\n}\n```",
        "uml": "images/state.png"
    },
    {
        "name": "Builder",
        "category": "Creational",
        "description": "El patrón Builder permite la construcción de objetos complejos paso a paso. Es particularmente útil para crear objetos con muchos parámetros opcionales.",
        "implementation": "```java\npublic class Product {\n    private final String part1;\n    private final String part2;\n    private final String part3;\n\n    private Product(Builder builder) {\n        this.part1 = builder.part1;\n        this.part2 = builder.part2;\n        this.part3 = builder.part3;\n    }\n\n    public static class Builder {\n        private String part1;\n        private String part2;\n        private String part3;\n\n        public Builder setPart1(String part1) {\n            this.part1 = part1;\n            return this;\n        }\n\n        public Builder setPart2(String part2) {\n            this.part2 = part2;\n            return this;\n        }\n\n        public Builder setPart3(String part3) {\n            this.part3 = part3;\n            return this;\n        }\n\n        public Product build() {\n            return new Product(this);\n        }\n    }\n}\n```",
        "uml": "images/builder.png"
    },
    {
        "name": "Strategy",
        "category": "Behavioral",
        "description": "El patrón Strategy define una familia de algoritmos, encapsula cada uno de ellos y los hace intercambiables. Strategy permite que el algoritmo varíe independientemente de los clientes que lo utilizan.",
        "implementation": "```java\npublic interface Strategy {\n    void execute();\n}\n\npublic class ConcreteStrategyA implements Strategy {\n    public void execute() {\n        // Implementación específica\n    }\n}\n\npublic class ConcreteStrategyB implements Strategy {\n    public void execute() {\n        // Implementación específica\n    }\n}\n\npublic class Context {\n    private Strategy strategy;\n    public void setStrategy(Strategy strategy) {\n        this.strategy = strategy;\n    }\n    public void executeStrategy() {\n        strategy.execute();\n    }\n}\n```",
        "uml": "images/strategy.png"
    },
    {
        "name": "Template Method",
        "category": "Behavioral",
        "description": "El patrón Template Method define el esqueleto de un algoritmo en una operación, diferiendo algunos pasos a las subclases. Permite que las subclases redefinan ciertos pasos de un algoritmo sin cambiar su estructura.",
        "implementation": "```java\npublic abstract class AbstractClass {\n    public final void templateMethod() {\n        primitiveOperation1();\n        primitiveOperation2();\n    }\n    protected abstract void primitiveOperation1();\n    protected abstract void primitiveOperation2();\n}\n\npublic class ConcreteClass extends AbstractClass {\n    protected void primitiveOperation1() {\n        // Implementación específica\n    }\n    protected void primitiveOperation2() {\n        // Implementación específica\n    }\n}\n```",
        "uml": "images/template_method.png"
    },
    {
        "name": "Visitor",
        "category": "Behavioral",
        "description": "El patrón Visitor representa una operación que se va a realizar sobre los elementos de una estructura de objeto. Permite definir una nueva operación sin cambiar las clases de los elementos sobre los cuales opera.",
        "implementation": "public interface Visitor {\n    void visit(ElementA elementA);\n    void visit(ElementB elementB);\n}\n\npublic class ConcreteVisitor implements Visitor {\n    public void visit(ElementA elementA) {\n        // Implementación específica\n    }\n    public void visit(ElementB elementB) {\n        // Implementación específica\n    }\n}\n\npublic interface Element {\n    void accept(Visitor visitor);\n}\n\npublic class ElementA implements Element {\n    public void accept(Visitor visitor) {\n        visitor.visit(this);\n    }\n}\n\npublic class ElementB implements Element {\n    public void accept(Visitor visitor) {\n        visitor.visit(this);\n    }\n}\n```",
        "uml": "https://postimg.cc/xJwpmDZ4"
    }
]
